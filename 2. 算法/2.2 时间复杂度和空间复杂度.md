#  时间复杂度和空间复杂度
衡量一个算法优劣的两个维度:
1. 时间复杂度: 评估算法执行所需的时间, 可以估算出算法对处理器的使用程度
2. 空间复杂度: 评估算法执行所需的空间, 可以估算出算法对计算机内存的使用程度

一个算法真实的运行时间和机器的配置有关, 配置越高程序运行的越快

## [大O标记法](https://zh.wikipedia.org/wiki/%E5%A4%A7O%E7%AC%A6%E5%8F%B7)
大O标记法用于描述函数的渐进行为, 大O标记法在分析算法效率的时候非常有用. 

一般我们我们评估一个算法都是直接评估它的最坏的复杂度.

大O标记法的语法:
```
O(fn)
```

大O标记法的三个原则:
1. 用常数1取代运行时间中的所有加法常数
2. 只保留最高阶项
3. 去除最高阶的常数

### 常数阶
```javascript
let total = 0;
total = total + 1;
```

只要代码中没有循环结构, 复杂度就是 `O(1)`, 即常数阶

### 线性阶
```javascript
let total = 0; // 赋值 1 次, 记 1 个单位时间
for (let i = 0; i < n; i++) { // 赋值 1 次, 记 1 个单位时间; 比较一次, 记 n + 1 个单位时间; 自增记 n 个单位时间 合计: 2n + 2 
    total = i + 1; // 累加 n 次, 赋值 n 次, 合计 2n 个单位时间
}
```

以上代码合计耗时: `4n + 3` 个单位时间, 根据大O标记法的原则, 当 n 无穷大时, 忽略倍数 4 和常数 3, 则以上代码的时间复杂度为 `O(n)`.

### 对数阶
```javascript
let i = 1;
while(i < n) {
    i = i * 2;
}
```
TBD

### 平方阶
```javascript
for (let i = 0; i < n; i++) {
   for (let j = 0; i < n; j++) {
        j = i;
        j++;
   }
}
```

1次循环时间复杂度是 `O(n)`, 2 次循环时间复杂度是 `O(n^2)`, 3 次循环时间复杂度是 `O(n^2)`, k 次循环时间复杂度是 `O(n^k)`

## 总结
考虑时间复杂度的时候, 我们简化为思考 `n+1` 的时候, 循环次数如何变化, 如果不变则 `O(1)`,
线性则 `O(N)`, 对数则为 `log(N)`... 以此类推, 也就是说把 n 当作问题规模, 当n变化的时候, 执行次数的变化呈现什么规律.

考虑空间复杂度的时候, 我们简化为思考 n+1 的时候, 内存消耗的数量如何变化, 如果不变则为 `O(1)`,
线性则为 `O(N)`, 平方则为 `O(N2)`... 以此类推, 也就是说当 n 变化的时候, 内存消耗的变化呈现什么规律.